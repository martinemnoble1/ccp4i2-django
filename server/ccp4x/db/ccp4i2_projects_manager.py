import sys
import os
from pathlib import Path
import json
import uuid
import time
import traceback
import pathlib
import logging
from typing import List
from django.utils.text import slugify
from django.db import IntegrityError

from ccp4i2.pimple import MGQTmatplotlib

sys.path.append(str(pathlib.Path(MGQTmatplotlib.__file__).parent.parent))

from core import CCP4Utils
from core import CCP4File
from core import CCP4Container
from core import CCP4TaskManager
from core import CCP4ErrorHandling
from ccp4i2.dbapi import CCP4DbApi
from core import CCP4ProjectsManager
from core import CCP4Data
from core import CCP4ModelData
from core import CCP4PerformanceData
from xml.etree import ElementTree as ET
from . import models
from ..lib.utils import uuid_from_no_hyphens

logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger("root")

project_field_old_to_new = {
    "followfromjobid": "follow_from_job",
    "i1projectdirectory": "i1_project_directory",
    "i1projectname": "i1_project_name",
    "lastaccess": "last_access",
    "lastjobnumber": "last_job_number",
    # "parentprojectid": "parentprojectid",
    "projectcreated": "creation_time",
    "projectdirectory": "directory",
    "projectid": "uuid",
    "projectname": "name",
    # "userid": "userid",
}
project_field_new_to_old = {
    item[1]: item[0] for item in project_field_old_to_new.items()
}
project_field_new_to_old["follow_from_job_id"] = "followfromjobid"


class FakeDb(object):
    class FakeSignal:
        def emit(self, *arg, **kwarg):
            logger.info("Ive been asked to emit %s, %s", arg, kwarg)

    def __init__(self):
        self.projectReset = FakeDb.FakeSignal()
        super().__init__()

    def __getattribute__(self, __name):
        logger.debug("Fakedb being interrogated for %s", __name)
        return super().__getattribute__(__name)

    def getFileByJobContext(
        self,
        contextJobId=None,
        fileType=None,
        subType=None,
        contentFlag=None,
        projectId=None,
    ):

        assert contextJobId is not None
        assert fileType is not None

        contextJobIn = models.Jobs.objects.get(jobid=contextJobId)
        projectJobs = models.Jobs.objects.filter(
            parentjobid__isnull=True, projectid=contextJobIn.uuid
        )
        searchJobsList = [
            projectJob
            for projectJob in projectJobs
            if int(projectJob.jobnumber) <= int(contextJobIn.jobnumber)
        ]
        searchJobsList.reverse()

        while len(searchJobsList) > 0:
            contextJob = searchJobsList.pop()
            logger.info("Looking for context in %s", contextJob.jobnumber)
            # First considering output/import files of job
            filterDict = {"filetypeid__filetypename": fileType}
            if isinstance(subType, list) and 0 not in subType and subType is not None:
                filterDict["filesubtype__in"] = subType
            elif not isinstance(subType, list) and subType != 0 and subType is not None:
                filterDict["filesubtype"] = subType
            if contentFlag is not None and contentFlag is not NotImplemented:
                if not isinstance(contentFlag, list):
                    filterDict["filecontent"] = contentFlag
                else:
                    filterDict["filecontent__in"] = contentFlag
            if projectId is not None:
                filterDict["jobid__projectid__projectid"] = projectId
            logger.debug("Using filterDict %s", filterDict)
            fileQS = models.Files.objects.filter(**filterDict)

            # See if there is an item generated by import / output from the context Job
            jobFileQS = fileQS.filter(jobid=contextJob)
            if len(list(jobFileQS)) > 0:
                jobFileIdList = [jobFile.fileid for jobFile in jobFileQS]

                # Separate output files and import files
                importFileIds = [
                    importFile.fileid.fileid
                    for importFile in models.Importfiles.objects.filter(
                        fileid__fileid__in=jobFileIdList
                    )
                ]
                outputFileIds = [
                    jobFileId
                    for jobFileId in jobFileIdList
                    if jobFileId not in importFileIds
                ]

                if len(outputFileIds) > 0:
                    if contextJob.taskname == "coot_rebuild":
                        return outputFileIds.reverse()
                    else:
                        return outputFileIds
                elif len(importFileIds) > 0:
                    return importFileIds

            filterDict = {"fileid__filetypeid__filetypename": fileType}
            if isinstance(subType, list) and not 0 in subType and subType is not None:
                filterDict["fileid__filesubtype__in"] = subType
            elif not isinstance(subType, list) and subType != 0 and subType is not None:
                filterDict["fileid__filesubtype"] = subType
            if contentFlag is not None and contentFlag is not NotImplemented:
                if not isinstance(contentFlag, list):
                    filterDict["fileid__filecontent"] = contentFlag
                else:
                    filterDict["fileid__filecontent__in"] = contentFlag
            if projectId is not None:
                filterDict["jobid__projectid__projectid"] = projectId

            fileuseQS = models.Fileuses.objects.filter(**filterDict)
            jobFileuseQS = fileuseQS.filter(jobid=contextJob)
            if len(list(jobFileuseQS)) > 0:
                outputFileQS = jobFileuseQS.filter(roleid__roletext="in")
                if len(list(outputFileQS)) > 0:
                    outputIdList = [
                        outputFile.fileid.fileid for outputFile in outputFileQS
                    ]
                    if contextJob.taskname == "coot_rebuild":
                        return outputIdList.reverse()
                    else:
                        return outputIdList
                inputFileQS = jobFileuseQS.filter(roleid__roletext="out")
                if len(list(inputFileQS)) > 0:
                    inputIdList = [inputFile.fileid.fileid for inputFile in inputFileQS]
                    return inputIdList

        return []

    def getTaskNameLookup(self, projectId=None, jobId=None, extras=False):
        # Fixme....this should produce a lookup of subtasks sfor use in CCP4i2 purgeJob
        try:
            logger.warning(
                "In unimplemented toutine getTaskNameLookup %s, %s, %s",
                projectId,
                jobId,
                extras,
            )
        except Exception as err:
            logger.warning("Err in unimplemented routine getTaskNameLookup %s", err)
            traceback.print_stack()
        return {}

    def getProjectInfo(
        self, projectId=None, projectName=None, mode="all", checkPermission=True
    ):
        if projectId is not None and "-" not in projectId:
            projectId = uuid_from_no_hyphens(projectId)
        try:
            if projectId is None:
                theQS = models.Project.objects.filter(name=projectName)
            else:
                theQS = models.Project.objects.filter(uuid=projectId)

            if isinstance(mode, list):
                arg = [item.lower() for item in mode]
            elif mode.lower() == "all":
                arg = []
            else:
                arg = [mode.lower()]
                arg = [project_field_old_to_new[an_arg] for an_arg in arg]
            unPatchedValues = theQS.values(*arg)
            values = []
            for unPatchedValue in unPatchedValues:
                value = {
                    project_field_new_to_old[key]: unPatchedValue[key]
                    for key in unPatchedValue
                }
                values.append(value)
            result = list(values)[0]
            if len(arg) == 1:
                return result[project_field_new_to_old[arg[0]]]
            return result
        except Exception as err:
            logger.exception("Err in getProjectInfo %s", err)
        return None

    def deleteFilesOnJobNumberAndParamName(self, projectId=None, jobNumberParamList=[]):
        try:
            for jobNumberParam in jobNumberParamList:
                # print('Requested to delete', jobNumberParam)
                try:
                    file = models.Files.objects.get(
                        jobid__projectid=projectId,
                        jobid__jobnumber=jobNumberParam[0],
                        jobparamname=jobNumberParam[1],
                    )
                    file.delete()
                except models.Files.DoesNotExist as err:
                    logger.info(
                        "Err in deleteFilesOnJobNumberAndParamName %s %s",
                        err,
                        jobNumberParam,
                    )
        except Exception as err:
            logger.info("Err in deleteFilesOnJobNumberAndParamName %s", err)
            traceback.print_stack()
        return None

    def getFileInfo(self, fileId=None, mode="all", returnType=None):
        assert fileId is not None
        theFileQS = models.File.objects.filter(uuid=fileId)

        if isinstance(mode, list):
            arg = [item.lower() for item in mode]
        elif mode.lower() == "all":
            arg = []
        else:
            arg = [mode.lower()]

        # Will need corrected for some cases
        replacements = {}

        def patch(label):
            return replacements.get(label, label)

        arg = list(map(patch, arg))

        unPatchedValues = theFileQS.values(*arg)
        listOfDicts = []
        for unPatchedValue in unPatchedValues:
            # outer loop over jobs matching jobId
            value = {}
            for key in unPatchedValue:
                # inner loop over parameters
                if key.endswith("_id"):
                    value[key[:-3]] = unPatchedValue[key]
                else:
                    value[key] = unPatchedValue[key]
            listOfDicts.append(value)
        result = listOfDicts[0]

        if len(arg) == 1 and returnType != dict:
            return result[arg[0]]
        elif returnType == list:
            return [item[1] for item in result.items()]
        return result

    def getJobInfo(
        self, jobId=None, mode="all", projectName=None, jobNumber=None, returnType=None
    ):
        try:
            # logger.info(f'jobId is {jobId}')
            if jobId is None:
                theJobQS = models.Jobs.objects.filter(
                    projectid__projectname=projectName, jobnumber=jobNumber
                )
            else:
                theJobQS = models.Jobs.objects.filter(jobid=jobId)
            assert len(list(theJobQS)) == 1

            if isinstance(mode, list):
                arg = [item.lower() for item in mode]
            elif mode.lower() == "all":
                arg = []
            else:
                arg = [mode.lower()]

            replacements = {
                "projectname": "projectid__projectname",
                "projectid": "projectid__projectid",
            }

            def patch(label):
                return replacements.get(label, label)

            arg = list(map(patch, arg))

            unPatchedValues = theJobQS.values(*arg)
            listOfDicts = []
            for unPatchedValue in unPatchedValues:
                # outer loop over jobs matching jobId
                value = {}
                for key in unPatchedValue:
                    # inner loop over parameters
                    if key == "projectid__projectname":
                        value["projectname"] = unPatchedValue[key]
                    elif key == "projectid__projectid":
                        value["projectid"] = unPatchedValue[key]
                    elif key.endswith("_id"):
                        value[key[:-3]] = unPatchedValue[key]
                    else:
                        value[key] = unPatchedValue[key]
                listOfDicts.append(value)
            result = listOfDicts[0]
            result["fileroot"] = list(theJobQS)[0].jobDirectory

            if len(arg) == 1 and returnType != dict:
                return result[arg[0]]
            elif returnType == list:
                return [item[1] for item in result.items()]

            jobFiles = models.Files.objects.filter(jobid=list(theJobQS)[0])
            result["filenames"] = {}
            for jobFile in jobFiles:
                result["filenames"][jobFile.jobparamname] = jobFile.filePath
            logger.info("Response from getJobInfo is %s", result)
            traceback.print_stack()
            return result
        except Exception as err:
            logger.info("Err in getJobInfo %s %s %s", err, mode, returnType)
            traceback.print_stack()
        return None

    def gleanJobFiles(
        self,
        jobId=None,
        container=None,
        dbOutputData=None,
        roleList=[CCP4DbApi.FILE_ROLE_OUT, CCP4DbApi.FILE_ROLE_IN],
        unSetMissingFiles=True,
    ):
        try:
            theJob = models.Jobs.objects.get(jobid=jobId)
            for role in roleList:
                roleid = models.Fileroles.objects.get(roleid=role)
                inputOutputFiles = self.findInputOutputs(container, role, [])
                for inputOutputFile in inputOutputFiles:

                    if isinstance(
                        inputOutputFile, CCP4PerformanceData.CPerformanceIndicator
                    ):
                        try:
                            objList, xmlText, keyValues = inputOutputFile.saveToDb()
                            jobParamName = inputOutputFile.objectName()
                        except:
                            logger.info(
                                "ERROR in gleanJobFiles for %s",
                                inputOutputFile.objectName(),
                            )
                            objList, xmlText, keyValues = [], None, {}
                            jobParamName = ""
                        for key, value in keyValues.items():
                            keyType = models.Keytypes.objects.get(keytypename=key)
                            if isinstance(value, str):
                                newKeyvalue = models.Jobkeycharvalues(
                                    jobid=theJob, keytypeid=keyType, value=value
                                )
                                newKeyvalue.save()
                            else:
                                keyType = models.Keytypes.objects.get(keytypename=key)
                                newKeyvalue = models.Jobkeyvalues(
                                    jobid=theJob, keytypeid=keyType, value=value
                                )
                                newKeyvalue.save()

                    elif isinstance(inputOutputFile, CCP4File.CDataFile):
                        logger.info(
                            "Gleaning %s - %s",
                            inputOutputFile.objectName(),
                            inputOutputFile.getFullPath(),
                        )
                        jobParamName = inputOutputFile.objectName()
                        if len(inputOutputFile.getFullPath()) > 0:
                            try:
                                if (
                                    inputOutputFile.dbFileId is not None
                                    and len(str(inputOutputFile.dbFileId)) != 0
                                ):
                                    theFile = models.Files.objects.get(
                                        fileid=str(inputOutputFile.dbFileId)
                                    )
                                    # If the file was imported, there may already be a fileUse record for it: if not, create one
                                    try:
                                        existingFileUse = models.Fileuses.objects.get(
                                            fileid=theFile, jobid=theJob, roleid=roleid
                                        )
                                    except models.Fileuses.DoesNotExist:
                                        newFileUse = models.Fileuses(
                                            fileid=theFile,
                                            jobid=theJob,
                                            roleid=roleid,
                                            jobparamname=jobParamName,
                                        )
                                        newFileUse.save()
                            except models.Fileuses.DoesNotExist as err:
                                logger.info(
                                    "ObjectDoesNotExist issue gleaning %s - file not found",
                                    jobParamName,
                                )
                                continue
                            except IntegrityError as err:
                                logger.info(
                                    "IntegrityError Issue gleaning %s %s %s %s",
                                    jobParamName,
                                    inputOutputFile.dbFileId,
                                    roleid.roleid,
                                    theFile.filename,
                                )
                                continue

                            if role == CCP4DbApi.FILE_ROLE_OUT:
                                if inputOutputFile.exists():
                                    fileTypeName = inputOutputFile.qualifiers(
                                        "mimeTypeName"
                                    )
                                    if len(fileTypeName) == 0:
                                        logger.info(
                                            "Class %s Does not have an associated mimeTypeName....ASK FOR DEVELOPER FIX",
                                            str(inputOutputFile.__class__),
                                        )
                                        if isinstance(
                                            inputOutputFile, CCP4File.CXmlDataFile
                                        ):
                                            fileTypeName = "application/xml"
                                    try:
                                        fileTypeId = models.Filetypes.objects.get(
                                            filetypename=fileTypeName
                                        )

                                        if inputOutputFile.subType != None:
                                            subType = int(inputOutputFile.subType)
                                        else:
                                            subType = None

                                        if inputOutputFile.contentFlag != None:
                                            fileContent = int(
                                                inputOutputFile.contentFlag
                                            )
                                        else:
                                            fileContent = None
                                        # print('Ready to save', fileContent,
                                        #      subType, fileTypeId.filetypeid, jobParamName)
                                        newFile = models.Files(
                                            filename=str(inputOutputFile.baseName),
                                            annotation=str(inputOutputFile.annotation),
                                            filetypeid=fileTypeId,
                                            filesubtype=subType,
                                            filecontent=fileContent,
                                            jobid=theJob,
                                            jobparamname=jobParamName,
                                            pathflag=1,
                                        )
                                        newFile.save()
                                        newFileUse = models.Fileuses(
                                            fileid=newFile,
                                            jobid=theJob,
                                            roleid=roleid,
                                            jobparamname=jobParamName,
                                        )
                                        newFileUse.save()
                                    except Exception as err:
                                        logger.info(
                                            "Issue saving new file %s - filetype ]%s] not recognised",
                                            jobParamName,
                                            fileTypeName,
                                        )

            return 0
        except Exception as err:
            logger.info("Err in gleanFiles %s", err)
            traceback.print_stack()
        return None

    def findInputOutputs(self, ofContainer, role, inputOutputsFound=[]):
        if isinstance(ofContainer, str):
            logger.info("Cant findInputOutputs of string %s", ofContainer)
            return inputOutputsFound
        else:
            for child in ofContainer.children():
                if isinstance(child, CCP4PerformanceData.CPerformanceIndicator):
                    inputOutputsFound.append(child)
                elif isinstance(child, CCP4Container.CContainer):
                    if (
                        role == CCP4DbApi.FILE_ROLE_IN
                        and child.objectName() != "outputData"
                    ):
                        self.findInputOutputs(
                            child, role, inputOutputsFound=inputOutputsFound
                        )
                    elif (
                        role == CCP4DbApi.FILE_ROLE_OUT
                        and child.objectName() == "outputData"
                    ):
                        self.findInputOutputs(
                            child, role, inputOutputsFound=inputOutputsFound
                        )
                elif isinstance(child, CCP4Data.CList):
                    for item in child:
                        if isinstance(item, CCP4File.CDataFile):
                            if len(item.objectName()) == 0:
                                item.setObjectName(child.objectName())
                            inputOutputsFound.append(item)
                        elif isinstance(item, CCP4Container.CContainer):
                            self.findInputOutputs(
                                item, role, inputOutputsFound=inputOutputsFound
                            )
                elif isinstance(child, CCP4File.CDataFile):
                    inputOutputsFound.append(child)
            return inputOutputsFound


class FakeProjectsManager(object):

    def __init__(self):
        logger.info("FakePM Init in")
        self._db = FakeDb()
        logger.info("FakePM Init out")
        super().__init__()

    def db(self):
        return self._db

    def __getattribute__(self, __name):
        logger.info("FakeProjectsManager being interrogated for %s", __name)
        return super().__getattribute__(__name)

    def setOutputFileNames(
        self, container=None, projectId=None, jobNumber=None, force=True
    ):
        myErrorReport = CCP4ErrorHandling.CErrorReport()
        relPath = os.path.sep.join(
            ["CCP4_JOBS"]
            + [f"job_{numberElement}" for numberElement in jobNumber.split(".")]
        )
        theJob = models.Jobs.objects.get(
            projectid__projectid=projectId, jobnumber=jobNumber
        )
        jobName = f"{jobNumber}_{slugify(theJob.uuid.name)}_{theJob.taskname}_"
        dataList = container.outputData.dataOrder()
        for objectName in dataList:
            try:
                dobj = container.outputData.find(objectName)
                # print 'setOutputData get',objectName,dobj.get(),dobj.isSet()
                if isinstance(dobj, CCP4File.CDataFile) and (force or not dobj.isSet()):
                    dobj.setOutputPath(
                        jobName=jobName, projectId=projectId, relPath=relPath
                    )
                if isinstance(dobj, CCP4ModelData.CPdbDataFile):
                    oldBaseName, oldExt = os.path.splitext(str(dobj.baseName))
                    if dobj.contentFlag is None or int(dobj.contentFlag) == 1:
                        dobj.baseName.set(f"{oldBaseName}.pdb")
                    if int(dobj.contentFlag) == 2:
                        dobj.baseName.set(f"{oldBaseName}.cif")

            except Exception as err:
                logger.info(
                    "Exception in setOutputFileNames for %s %s",
                    dobj.objectPath(),
                    str(err),
                )
        return myErrorReport

    def interpretDirectory(self, path):
        absPath = os.path.abspath(path)
        logger.info("absPath %s", absPath)
        theProject = None
        for project in models.Project.objects.all():
            # print(project.name, '{}/'.format(project.directory))
            if absPath.startswith("{}/".format(project.directory)):
                theProject = project
                break
        if theProject is not None:
            # projectName, relPath, projectId
            return (
                theProject.name,
                absPath[len(theProject.directory) + 1 :],
                theProject.uuid,
            )
        else:
            return [None, None, None]

    def getProjectDirectory(self, projectName=None, testAlias=True, projectId=None):
        logger.info(
            "*****In FakeGetProjectDirectory %s, %s, %s",
            projectName,
            testAlias,
            projectId,
        )
        if projectId is not None:
            # Baffling edge case
            if testAlias and projectId == "CCP4I2_TOP":
                return os.environ["CCP4I2_TOP"]
            try:
                if "-" not in projectId:
                    projectId = uuid_from_no_hyphens(projectId)
                theProject = models.Project.objects.get(uuid=projectId)
            except models.Project.DoesNotExist as err:
                logger.info(
                    "In getProjectDirectory for non existent projectId %s", projectId
                )
                return None
        else:
            try:
                theProject = models.Project.objects.get(name=projectName)
            except models.Project.DoesNotExist as err:
                logger.info(
                    "In getProjectDirectory for non existent projectName %s",
                    projectName,
                )
                return None
        return theProject.directory

    def jobDirectory(self, jobId=None, projectName=None, jobNumber=None):
        assert jobId is not None or (projectName is not None and jobNumber is not None)
        # logger.info('in FPM %s, %s, %s', jobId, projectName, jobNumber)
        if jobId is not None:
            return models.Jobs.objects.get(jobid=jobId).jobDirectory
        else:
            return models.Jobs.objects.get(
                projectid__projectname=projectName, jobnumber=jobNumber
            ).jobDirectory

    def makeFileName(self, jobId=None, mode="PROGRAMXML"):
        theJob = models.Job.objects.get(uuid=jobId)
        defNames = {
            "ROOT": "",
            "PARAMS": "params.xml",
            "JOB_INPUT": "input_params.xml",
            "PROGRAMXML": "program.xml",
            "LOG": "log.txt",
            "STDOUT": "stdout.txt",
            "STDERR": "stderr.txt",
            "INTERRUPT": "interrupt_status.xml",
            "DIAGNOSTIC": "diagnostic.xml",
            "REPORT": "report.html",
            "DIAGNOSTIC_REPORT": "diagnostic_report.html",
            "TABLE_RTF": "tables.rtf",
            "TABLES_DIR": "tables_as_csv_files",
            "XML_TABLES_DIR": "tables_as_xml_files",
            "LOG": "log.txt",
            "COM": "com.txt",
            "MGPICDEF": "report.mgpic.py",
            "PIC": "report.png",
            "RVAPIXML": "i2.xml",
        }
        jobPath = Path(theJob.directory) / defNames[mode]
        return str(jobPath)


# Decoorator to install and use FakeProjectManager


def UsingFakePM(func):
    def wrapper(*args, **kwargs):
        logger.info("Something is happening before the function is called.")
        oldPM = CCP4ProjectsManager.CProjectsManager.insts
        try:
            CCP4ProjectsManager.CProjectsManager.insts = FakeProjectsManager()
            result = func(*args, **kwargs)
        except Exception as err:
            logging.error("Encountered issue while in FakePM decorator %s", err)
            traceback.print_exc()
        finally:
            CCP4ProjectsManager.CProjectsManager.insts = oldPM
            logger.info("Something is happening after the function is called.")
        return result

    return wrapper


def modelValues(objectType="", predicate={}, order_byArray=[], valuesArray=[]):
    try:
        ModelClass = getattr(models, objectType)
        querySet = ModelClass.objects.all()
        if len(predicate.items()) > 0:
            for key in predicate:
                if key.endswith("isnull"):
                    logger.info("%s %s", key, predicate[key])
                    if "true" in predicate[key].lower():
                        predicate[key] = True
                    elif "false" in predicate[key].lower():
                        predicate[key] = False
                logger.info("%s", predicate)
            querySet = querySet.filter(**predicate)
        if len(order_byArray) > 0:
            querySet = querySet.order_by(*order_byArray)
        # logger.info(model, filterDict, valuesArray, order_byArray)
        valuesQuerySet = querySet.values(*valuesArray)
        status = "Success"
        exception = ""
    except Exception as err:
        exception = str(err)
        valuesQuerySet = []
        status = "Failure"
    return {"results": list(valuesQuerySet), "status": status, "Exception": exception}


def makeTerminateFile(queryDict):
    theJob = models.Jobs.objects.get(jobid=queryDict["jobId"])
    terminateFilePath = os.path.join(theJob.jobDirectory, "TERMINATE")
    with open(terminateFilePath, "w") as terminateFile:
        terminateFile.write("TERMINATE")
    return json.dumps({"status": "Success"}), "application/json"


def getJobFile(
    jobId=None, projectId=None, projectName=None, jobNumber=None, fileName=None
):
    if jobId is not None:
        theJob = models.Jobs.objects.get(jobid=jobId)
    elif jobNumber is None or (projectId is None or projectName is None):
        raise Exception("need jobId or (jobNumber and (projectId or projectName))")
    elif projectId is None:
        theJob = models.Jobs.objects.get(projectname=projectName, jobnumber=jobNumber)
    else:
        theJob = models.Jobs.objects.get(projectname=projectName, jobnumber=jobNumber)

    filePath = os.path.join(theJob.jobDirectory, fileName)
    with open(filePath, "r") as f:
        d = f.read()
    return d


def getFileWithPredicate(predicate):
    theFile = models.Files.objects.get(**predicate)
    filePath = theFile.filePath
    with open(filePath, "rb") as f:
        d = f.read()
    return d, filePath, theFile.filetypeid.filetypename


def getProjectFileData(projectId, relPath, baseName):
    from urllib.parse import unquote

    relPath = unquote(relPath)
    filePath = os.path.join(
        models.Projects.objects.get(projectid=projectId).directory,
        relPath,
        baseName,
    )
    with open(filePath, "rb") as f:
        d = f.read()
    return d, filePath


def jobForPredicate(jobId=None, projectId=None, projectName=None, jobNumber=None):
    logger.info("%s, %s, %s, %s", jobId, projectId, projectName, jobNumber)
    if jobId is None:
        if projectId is not None:
            jobs = models.Jobs.objects.filter(projectid__projectid=projectId)
        else:
            jobs = models.Jobs.objects.filter(projectid__projectname=projectName)
        theJob = jobs.get(jobnumber=str(jobNumber))
    else:
        theJob = models.Jobs.objects.get(jobid=jobId)
    return theJob


@UsingFakePM
def uploadFileToJob(fileRoot="output", jobId=None, fileExtension=".txt", file=b""):
    theJob = models.Jobs.objects.get(jobid=jobId)
    baseName = f"{fileRoot}{fileExtension}"
    filePath = os.path.join(theJob.jobDirectory, baseName)
    iFile = 0
    while os.path.exists(filePath):
        baseName = f"{fileRoot}_{iFile}{fileExtension}"
        filePath = os.path.join(theJob.jobDirectory, baseName)
        iFile += 1
    with open(filePath, "wb") as outputFile:
        outputFile.write(file)
    relPath = os.path.join(
        "CCP4_JOBS", "/".join([f"job_{jN}" for jN in theJob.jobnumber.split(".")])
    )
    return {
        "project": theJob.uuid.uuid,
        "relPath": relPath,
        "baseName": baseName,
    }


@UsingFakePM
def uploadFileForJobObject(
    jobId=None,
    projectId=None,
    projectName=None,
    jobNumber=None,
    objectPath=None,
    fileName=None,
    file=b"",
):
    if jobId is None and (
        (projectId is None and projectName is None) or jobNumber is None
    ):
        raise Exception("Unable to infer job in uploadFileForJobObject")
    if fileName is None:
        raise Exception("No fileName given for uploadFileForJobObject")
    theJob = jobForPredicate(
        jobId=jobId, projectId=projectId, projectName=projectName, jobNumber=jobNumber
    )

    fileRoot, fileExtension = os.path.splitext(fileName)
    uploadResult = uploadFileToJob(fileRoot, theJob.jobid, fileExtension, file)
    valueXMLText = f"""<{objectPath.split('.')[-1]}>
        <project>{uploadResult['project']}</project>
        <relPath>{uploadResult['relPath']}</relPath>
        <baseName>{uploadResult['baseName']}</baseName>
        <annotation>Imported from upload of {fileName}</annotation>
    </{objectPath.split('.')[-1]}>"""
    setJobParameterByXML(jobId, objectPath, valueXMLText)
    theJobPlugin = getJobPlugin(theJob)
    objectElement = theJobPlugin.container.locateElement(objectPath)
    # Here validate the file by attempting to load it and apply setContentFlag
    objectElement.loadFile()
    objectElement.setContentFlag()
    saveParamsForJob(theJobPlugin=theJobPlugin, theJob=theJob)
    return ET.tostring(objectElement.getEtree()).decode("utf-8")


def getProjectDirectory(projectId=None, projectName=None, jobId=None):
    if projectId is not None:
        return models.Projects.objects.get(projectid=projectId).directory
    elif projectName is not None:
        return models.Projects.objects.get(projectname=projectName).directory
    elif jobId is not None:
        return models.Jobs.objects.get(jobid=jobId).uuid.directory
    return None


def getProjectJobFileName(
    projectId=None, fileName=None, jobNumber="1", subJobNumber=""
):
    # MN: This is mostly deeply flawed logic, and not at all how job numbers should work ! Copied from CDbApi and rescued for
    # "." in jobNumber
    if subJobNumber != "":
        fname = os.path.join(
            getProjectDirectory(projectId=projectId),
            "CCP4_JOBS",
            "job_" + jobNumber,
            "job_" + subJobNumber,
            fileName,
        )
    else:
        if "." in jobNumber:
            jobNumberPathElements = [f"job_{number}" for number in jobNumber.split(".")]
            fname = os.path.join(
                getProjectDirectory(projectId=projectId),
                "CCP4_JOBS",
                *jobNumberPathElements,
                fileName,
            )
        else:
            fname = os.path.join(
                getProjectDirectory(projectId=projectId),
                "CCP4_JOBS",
                "job_" + jobNumber,
                fileName,
            )
    return fname


@UsingFakePM
def getProjectJobFile(
    projectId=None, projectName=None, fileName=None, jobNumber="1", subJobNumber=""
):
    if projectId is None:
        if projectName is not None:
            projectId = models.Projects.objects.get(projectname=projectName).uuid
    fname = getProjectJobFileName(projectId, fileName, jobNumber, subJobNumber)
    d = fname
    if fname.endswith(".png"):
        with open(fname, "rb") as f:
            d = f.read()
    else:
        with open(fname, "rb") as f:
            d = f.read()
    return d


@UsingFakePM
def removeDefaults(container):
    for child in container.children():
        if hasattr(child, "objectName") and child.objectName() not in [
            "inputData",
            "outputData",
        ]:
            if isinstance(child, CCP4Container.CContainer):
                if child.objectName() != "outputData":
                    removeDefaults(child)
            else:
                if not child.isSet(allowDefault=False, allSet=False):
                    if container.objectName() != "temporary":
                        try:
                            container.deleteObject(child.objectName())
                        except Exception as err:
                            logger.info(
                                "Issue deleting %s from %s",
                                child.objectName(),
                                container.objectName(),
                            )


@UsingFakePM
def cloneJob(jobId=None):
    oldJob = models.Jobs.objects.get(jobid=jobId)
    theProject = oldJob.uuid

    taskName = oldJob.taskname

    try:
        lastJobNumber = max(
            [
                int(job.jobnumber)
                for job in models.Jobs.objects.filter(projectid=theProject).filter(
                    parentjobid__isnull=True
                )
            ]
        )
    except ValueError:
        lastJobNumber = 0

    nextJobNumber = str(lastJobNumber + 1)

    try:
        preceedingJobId = models.Jobs.objects.get(
            projectid=theProject, jobnumber=str(lastJobNumber)
        )
    except models.Jobs.DoesNotExist as err:
        preceedingJobId = None

    newJobDir = (
        Path(theProject.directory) / "CCP4_JOBS" / "job_{}".format(nextJobNumber)
    )
    newJobId = uuid.uuid1().hex
    logger.info("newJobDir %s, newJobId %s", newJobDir, newJobId)
    from core import CCP4TaskManager

    taskManager = CCP4TaskManager.CTaskManager()
    pluginClass = taskManager.getPluginScriptClass(taskName)
    newJobDir.mkdir(exist_ok=True, parents=True)
    theJobPlugin = pluginClass(workDirectory=str(newJobDir))
    logger.info("theJobPlugin %s", theJobPlugin)

    # Load cloned parameters
    theJobPlugin.container.loadDataFromXml(
        str(Path(oldJob.jobDirectory) / "input_params.xml")
    )

    try:
        dataList = theJobPlugin.container.outputData.dataOrder()
        for objectName in dataList:
            dobj = theJobPlugin.container.outputData.find(objectName)
            if isinstance(dobj, CCP4File.CDataFile):
                dobj.unSet()
    except Exception as err:
        raise (err)

    newJob = models.Jobs(
        jobid=newJobId,
        jobnumber=str(nextJobNumber),
        finishtime=0.0,
        status=models.Jobstatus.objects.get(statustext="Pending"),
        evaluation=None,
        useragent=models.Useragents.objects.all()[0],
        jobtitle=taskManager.getTitle(taskName),
        projectid=theProject,
        taskname=taskName,
        taskversion=None,
        parentjobid=None,
        preceedingjobid=preceedingJobId,
        treeleft=None,
        treeright=None,
        userid=theProject.userid,
    )

    removeDefaults(theJobPlugin.container)
    saveParamsForJob(theJobPlugin, newJob)

    newJob.save()

    theProject.lastaccess = time.time()
    theProject.lastjobnumber = newJob.jobnumber
    theProject.save()

    return newJob.jobid, newJob.jobnumber, theProject.uuid, None


@UsingFakePM
def updateJobStatus(jobId=None, statusId=None):
    theJob = models.Jobs.objects.get(jobid=jobId)
    theStatus = models.Jobstatus.objects.get(statusid=statusId)
    theJob.status = theStatus
    theJob.save()
    return theJob.jobid, theJob.uuid.uuid, theStatus.statustext


@UsingFakePM
def createJob(
    projectId=None,
    projectName=None,
    parentJobId=None,
    taskName=None,
    jobNumber=None,
    jobId=None,
    saveParams=True,
):
    logger.info("%s, %s", projectName, projectId)
    if parentJobId is not None and projectId is None:
        parentJob = models.Jobs.objects.get(jobid=parentJobId)
        theProject = parentJob.uuid
    elif projectId is None and projectName is not None:
        parentJob = None
        theProject = models.Projects.objects.get(projectname=projectName)
        projectId = theProject.uuid
    else:
        parentJob = None
        theProject = models.Projects.objects.get(projectid=projectId)

    if jobNumber is None:
        projectJobs = models.Jobs.objects.filter(projectid__projectid=projectId).filter(
            parentjobid__isnull=True
        )
        if len(projectJobs) == 0:
            lastJobNumber = 0
        else:
            lastJobNumber = sorted([int(a.jobnumber) for a in projectJobs])[-1]
        lastJobNumber = str(lastJobNumber)
    else:
        jobNumberElements = jobNumber.split(".")
        jobNumberElements[-1] = str(int(jobNumberElements[-1]) - 1)
        lastJobNumber = ".".join(jobNumberElements)

    jobNumberElements = lastJobNumber.split(".")
    jobNumberElements[-1] = str(int(jobNumberElements[-1]) + 1)
    nextJobNumber = ".".join(jobNumberElements)

    preceedingJobId = None
    try:
        preceedingJobId = models.Jobs.objects.get(
            projectid__projectid=projectId, jobnumber=str(lastJobNumber)
        )
    except models.Jobs.DoesNotExist as err:
        preceedingJobId = None

    pathElements = [theProject.directory, "CCP4_JOBS"] + [
        "job_{}".format(jNo) for jNo in jobNumberElements
    ]
    newJobString = os.path.join(*pathElements)
    newJobDir = Path(newJobString)

    if jobId is None:
        newJobId = uuid.uuid1().hex
    else:
        newJobId = jobId

    taskManager = CCP4TaskManager.CTaskManager()
    pluginClass = taskManager.getPluginScriptClass(taskName)
    if saveParams:
        newJobDir.mkdir(exist_ok=True, parents=True)
    theJobPlugin = pluginClass(workDirectory=str(newJobDir))

    argDict = dict(
        jobid=newJobId,
        jobnumber=str(nextJobNumber),
        creationtime=time.time(),
        finishtime=0.0,
        status=models.Jobstatus.objects.get(statustext="Pending"),
        evaluation=None,
        useragent=models.Useragents.objects.all()[0],
        jobtitle=taskManager.getTitle(taskName),
        projectid=theProject,
        taskname=taskName,
        taskversion=None,
        parentjobid=parentJob,
        preceedingjobid=preceedingJobId,
        treeleft=None,
        treeright=None,
        userid=theProject.userid,
    )
    logger.info("argDict %s", argDict)
    newJob = models.Jobs(**argDict)

    if saveParams:
        removeDefaults(theJobPlugin.container)
        saveParamsForJob(theJobPlugin, newJob)
    newJob.save()

    return newJob.jobid, newJob.jobnumber, theProject.uuid, parentJobId


@UsingFakePM
def getJobPlugin(theJob, parent=None, dbHandler=None):
    taskManager = CCP4TaskManager.CTaskManager()

    pluginClass = taskManager.getPluginScriptClass(theJob.taskname)
    try:
        pluginInstance = pluginClass(
            workDirectory=theJob.jobDirectory, parent=parent, dbHandler=dbHandler
        )
    except Exception as err:
        traceback.print_exc()

    defFile = os.path.join(theJob.jobDirectory, "params.xml")
    if not os.path.exists(defFile):
        # logger.info('No params.xml at %s', defFile)
        defFile1 = os.path.join(theJob.jobDirectory, "input_params.xml")
        if not os.path.exists(defFile1):
            # logger.info('No params.xml at %s', defFile1)
            raise Exception("no defFile found")
        defFile = defFile1
    pluginInstance.container.loadDataFromXml(defFile, check=False, loadHeader=False)
    return pluginInstance


@UsingFakePM
def saveParamsForJob(theJobPlugin, theJob, mode="JOB_INPUT", excludeUnset=True):
    # logger.info('into saveParams for %s excludeUnset: %s', theJob.jobnumber, excludeUnset)
    # sys.stdout.flush()
    fileName = theJobPlugin.makeFileName(mode)
    # logger.info('saveParams in %s', fileName)
    # sys.stdout.flush()
    if os.path.exists(fileName):
        backup = CCP4Utils.backupFile(fileName, delete=False)
    if theJobPlugin.container.header is None:
        theJobPlugin.container.addHeader()
    theJobPlugin.container.header.name.set(theJob.uuid.name)
    theJobPlugin.container.header.uuid.set(theJob.uuid.uuid)
    theJobPlugin.container.header.jobNumber.set(theJob.jobnumber)
    theJobPlugin.container.header.jobId.set(theJob.jobid)
    f = CCP4File.CI2XmlDataFile(fullPath=fileName)
    f.header.set(theJobPlugin.container.header)
    f.header.function.set("PARAMS")
    f.header.setCurrent()
    bodyEtree = theJobPlugin.container.getEtree(excludeUnset=excludeUnset)
    ET.indent(bodyEtree)
    f.saveFile(bodyEtree=bodyEtree)
    # logger.info('out of saveParams for %s excludeUnset: %s', theJob.jobnumber, excludeUnset)
    # sys.stdout.flush()

    return


@UsingFakePM
def getJobContainer(theJob):
    defFile = CCP4TaskManager.CTaskManager().lookupDefFile(
        name=theJob.taskname, version=None
    )
    # print 'CProjectDirToDb.globJobs defFile',defFile
    container = CCP4Container.CContainer()
    container.loadContentsFromXml(defFile, guiAdmin=True)
    if os.path.exists(os.path.join(theJob.jobDirectory, "params.xml")):
        container.loadDataFromXml(os.path.join(theJob.jobDirectory, "params.xml"))
    else:
        container.loadDataFromXml(os.path.join(theJob.jobDirectory, "input_params.xml"))
    return container


@UsingFakePM
def setJobParameterByXML(jobId, objectPath, valueXMLText):
    newValueEtree = ET.fromstring(valueXMLText)
    theJob = models.Jobs.objects.get(jobid=jobId)
    theJobPlugin = getJobPlugin(theJob)
    objectElement = theJobPlugin.container.locateElement(objectPath)
    objectElement.unSet()
    objectElement.setEtree(newValueEtree)
    saveParamsForJob(theJobPlugin=theJobPlugin, theJob=theJob)
    return ET.tostring(objectElement.getEtree()).decode("utf-8")
